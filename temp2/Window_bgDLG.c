/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.26                          *
*        Compiled Aug  8 2014, 14:49:54                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)

#include "Window_bgDLG.h"
#include "Window_bg2DLG.h"

#include "EmWinHZFont.h"
#include "GUI.h"
#include "malloc.h"
#include "ff.h"
#include "ili93xx.h"

#include "led.h"
#include "usart.h"

#if SYSTEM_SUPPORT_UCOS
#include "includes.h"					//ucos 使用	  
#endif



// USER END

#include "DIALOG.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0        (GUI_ID_USER + 0x00)
#define ID_BUTTON_0        (GUI_ID_USER + 0x01)


// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)

static FIL BMPFile;
static char bmpBuffer[BMPPERLINESIZE];


WM_HMEM win_bg;

//内存设备对象句柄
GUI_MEMDEV_Handle hBMP;


// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "Window_bg", ID_WINDOW_0, 0, 0, 240, 320, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_0, 0, 0, 80, 80, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)






//读数据函数
static int BmpGetData(void * p, const U8 ** ppData, unsigned NumBytesReq, U32 Off) 
{
	static int readaddress=0;
	FIL * phFile;
	UINT NumBytesRead;
	#if SYSTEM_SUPPORT_UCOS
		OS_CPU_SR cpu_sr;
	#endif
	
	phFile = (FIL *)p;
	
	if (NumBytesReq > sizeof(bmpBuffer)) 
	{
		NumBytesReq = sizeof(bmpBuffer);
	}

	//移动指针到应该读取的位置
	if(Off == 1) readaddress = 0;
	else readaddress=Off;
	#if SYSTEM_SUPPORT_UCOS
		OS_ENTER_CRITICAL();	//临界区
	#endif
	f_lseek(phFile,readaddress); 
	
	//读取数据到缓冲区中
	f_read(phFile,bmpBuffer,NumBytesReq,&NumBytesRead);
	#if SYSTEM_SUPPORT_UCOS
		OS_EXIT_CRITICAL();	//退出临界区 
	#endif
	*ppData = (U8 *)bmpBuffer;
	return NumBytesRead;//返回读取到的字节数
}

//在指定位置显示加载到RAM中的BMP图片
//BMPFileName:图片在SD卡或者其他存储设备中的路径(需文件系统支持！)
//mode:显示模式
//		0 在指定位置显示，有参数x,y确定显示位置
//		1 在LCD中间显示图片，当选择此模式的时候参数x,y无效。
//x:图片左上角在LCD中的x轴位置(当参数mode为1时，此参数无效)
//y:图片左上角在LCD中的y轴位置(当参数mode为1时，此参数无效)
//member:  缩放比例的分子项
//denom:缩放比例的分母项
//返回值:0 显示正常,其他 失败
int dispbmp(u8 *BMPFileName,u8 mode,u32 x,u32 y,int member,int denom)
{
	u16 bread;
	char *bmpbuffer;
	char result;
	int XSize,YSize;
	float Xflag,Yflag;

	
	#if SYSTEM_SUPPORT_UCOS
		OS_CPU_SR cpu_sr;
	#endif

	result = f_open(&BMPFile,(const TCHAR*)BMPFileName,FA_READ);	//打开文件
	//文件打开错误或者文件大于BMPMEMORYSIZE
	if((result != FR_OK) || (BMPFile.fsize>BMPMEMORYSIZE)) 	return 1;

	bmpbuffer = mymalloc(SRAMEX,BMPFile.fsize);//申请内存
	if(bmpbuffer == NULL) return 2;
	
	#if SYSTEM_SUPPORT_UCOS
		OS_ENTER_CRITICAL();	//临界区
	#endif
		
	result = f_read(&BMPFile,bmpbuffer,BMPFile.fsize,(UINT *)&bread); //读取数据
	if(result != FR_OK) return 3;
	
	#if SYSTEM_SUPPORT_UCOS
		OS_EXIT_CRITICAL();	//退出临界区
	#endif
	
	switch(mode)
	{
		case 0:	//在指定位置显示图片
			if((member == 1) && (denom == 1)) //无需缩放，直接绘制
			{
				GUI_BMP_Draw(bmpbuffer,x,y);	//在指定位置显示BMP图片
			}else //否则图片需要缩放
			{
				GUI_BMP_DrawScaled(bmpbuffer,x,y,member,denom);
			}
			break;
		case 1:	//在LCD中间显示图片
			XSize = GUI_BMP_GetXSize(bmpbuffer);	//获取图片的X轴大小
			YSize = GUI_BMP_GetYSize(bmpbuffer);	//获取图片的Y轴大小
			if((member == 1) && (denom == 1)) //无需缩放，直接绘制
			{
				//在LCD中间显示图片
				GUI_BMP_Draw(bmpbuffer,(lcddev.width-XSize)/2-1,(lcddev.height-YSize)/2-1);
			}else //否则图片需要缩放
			{
				Xflag = (float)XSize*((float)member/(float)denom);
				Yflag = (float)YSize*((float)member/(float)denom);
				XSize = (lcddev.width-(int)Xflag)/2-1;
				YSize = (lcddev.height-(int)Yflag)/2-1;
				GUI_BMP_DrawScaled(bmpbuffer,XSize,YSize,member,denom);
			}
			break;
	}
	f_close(&BMPFile);		//关闭BMPFile文件
	myfree(SRAMEX,bmpbuffer);	//释放内存
	return 0;
}


//使用内存设备显示bmp
int LoadBMP_UsingMEMDEV(u8 *BMPFileName,u32 x,u32 y)
{
	u16 bread;
	char *bmpbuffer;
	char result;
	int XSize,YSize;
	float Xflag,Yflag;

	
	#if SYSTEM_SUPPORT_UCOS
		OS_CPU_SR cpu_sr;
	#endif

	result = f_open(&BMPFile,(const TCHAR*)BMPFileName,FA_OPEN_EXISTING |FA_READ);	//打开文件
	//文件打开错误或者文件大于BMPMEMORYSIZE
	if((result != FR_OK) || (BMPFile.fsize>BMPMEMORYSIZE)) 	return 1;

	bmpbuffer = mymalloc(SRAMEX,BMPFile.fsize);//申请内存
	if(bmpbuffer == NULL) return 2;
	
	#if SYSTEM_SUPPORT_UCOS
		OS_ENTER_CRITICAL();	//临界区
	#endif
		
	result = f_read(&BMPFile,bmpbuffer,BMPFile.fsize,(UINT *)&bread); //读取数据
	if(result != FR_OK) return 3;
	
	f_close(&BMPFile);		//关闭BMPFile文件
	
	#if SYSTEM_SUPPORT_UCOS
		OS_EXIT_CRITICAL();	//退出临界区
	#endif
	
/* 创建内存设备 */
    hBMP = GUI_MEMDEV_CreateEx(x, y,            /* 起始坐标 */
                    GUI_BMP_GetXSize(bmpbuffer), /* x方向尺寸 */
                    GUI_BMP_GetYSize(bmpbuffer), /* y方向尺寸 */
                    GUI_MEMDEV_HASTRANS);        /* 带透明度的内存设备 */
    /* 选择内存设备 */
    GUI_MEMDEV_Select(hBMP);
    /* 绘制BMP到内存设备中 */
    GUI_BMP_Draw(bmpbuffer, x, y);
    /* 选择内存设备，0表示选中LCD */
    GUI_MEMDEV_Select(0);	
	
	myfree(SRAMEX,bmpbuffer);	//释放内存
	return 0;
}





static GUI_BITMAP Bitmap;
static GUI_LOGPALETTE Palette;
static char *bmpbuffer;

//使用流位图显示bmp
int showstreambitmap(u8 *BMPFileName,u32 x,u32 y)
{
	u16 bread;

	char result;
	int XSize,YSize;
	float Xflag,Yflag;

	
	#if SYSTEM_SUPPORT_UCOS
		OS_CPU_SR cpu_sr;
	#endif

	result = f_open(&BMPFile,(const TCHAR*)BMPFileName,FA_OPEN_EXISTING |FA_READ);	//打开文件
	//文件打开错误或者文件大于BMPMEMORYSIZE
	if((result != FR_OK) || (BMPFile.fsize>BMPMEMORYSIZE)) 	return 1;

	bmpbuffer = mymalloc(SRAMEX,BMPFile.fsize);//申请内存
	if(bmpbuffer == NULL) return 2;
	
	#if SYSTEM_SUPPORT_UCOS
		OS_ENTER_CRITICAL();	//临界区
	#endif
		
	result = f_read(&BMPFile,bmpbuffer,BMPFile.fsize,(UINT *)&bread); //读取数据
	if(result != FR_OK) return 3;
	
	f_close(&BMPFile);		//关闭BMPFile文件
	
	#if SYSTEM_SUPPORT_UCOS
		OS_EXIT_CRITICAL();	//退出临界区
	#endif
	
	
	GUI_CreateBitmapFromStream(&Bitmap, &Palette, bmpbuffer);

	
	
	
	GUI_DrawStreamedBitmapAuto(bmpbuffer, x, y);

	myfree(SRAMEX,bmpbuffer);	//释放内存
	return 0;
}


























void bmpdisplay_demo(void)
{
	dispbmp("0:/image/bg1.bmp",0,0,	0,	1,1);
	//showstreambitmap("0:/data/bg1.dta",0,0);
}


// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  int NCode;
  int Id;
	
	int t0=0,t1=0;
	

  // USER START (Optionally insert additional variables)
	
	//bmpdisplay_demo();
	//printf("inti\r\n");
	
	
	//GUI_DrawBitmap(&Bitmap, 0, 0);
	
  // USER END

  switch (pMsg->MsgId) {
	  
 case WM_INIT_DIALOG:
//	t0 = GUI_GetTime();
//	bmpdisplay_demo();
//	t1 = GUI_GetTime();
//	printf("paint: %dms\r\n",t1-t0);
	//WM_Paint(WM_HBKWIN);
	 break;
	  
 
//	//背景重绘
//	case WM_PAINT:
//		
//	t0 = GUI_GetTime();
//		
//	bmpdisplay_demo();
//	
//	t1 = GUI_GetTime();
//	
//	printf("paint: %dms\r\n",t1-t0);	
//	
//	//printf("paint\r\n");
//	
//	//GUI_DrawBitmap(&Bitmap, 0, 0);
//	
//	//GUI_DrawStreamedBitmapAuto(bmpbuffer, 0, 0);
//	
//	/* 从内存设备写入LCD */
//	//GUI_MEMDEV_CopyToLCDAt(hBMP,0,0);
//	//GUI_MEMDEV_WriteAt(hBMP,0,0);
//	//GUI_MEASDEV_Select(0);
//	
//	break; 
 
 
 
 
 
	  
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_0: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
//		WM_HideWin(win_bg);
//		WM_ShowWin(win_bg2);
	  
	  //WM_HideWin(win_bg);
		GUI_EndDialog(pMsg->hWin,0);
		CreateWindow_bg2();
	  
	  
		//WM_Paint(WM_HBKWIN);
//	  	t0 = GUI_GetTime();
//		bmpdisplay_demo();
//		t1 = GUI_GetTime();
//		printf("paint: %dms\r\n",t1-t0);
	  //GUI_MEMDEV_CopyToLCDAt(hBMP,0,0);
	  
	  
		//LED0 =~LED0;
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
	
	
	//	//背景重绘
	case WM_PAINT:
		
	t0 = GUI_GetTime();
		
	bmpdisplay_demo();
	
	//LoadBMP_UsingMEMDEV("0:/image/bg1.bmp",0,0);
	
	//GUI_MEMDEV_WriteAt(hBMP,0,0);
	
	//GUI_MEMDEV_WriteAt(hBMP,0,0);
	//GUI_MEASDEV_Select(0);
	
	t1 = GUI_GetTime();
	
	printf("paint: %dms\r\n",t1-t0);	
	
	//printf("paint\r\n");
	
	//GUI_DrawBitmap(&Bitmap, 0, 0);
	
	//GUI_DrawStreamedBitmapAuto(bmpbuffer, 0, 0);
	
	/* 从内存设备写入LCD */
	//GUI_MEMDEV_CopyToLCDAt(hBMP,0,0);
	//GUI_MEMDEV_WriteAt(hBMP,0,0);
	//GUI_MEASDEV_Select(0);
	
	break; 
	
	
	
	
	
	
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindow_bg
*/

WM_HWIN CreateWindow_bg(void) {
	WM_HWIN hWin;

	//bmpdisplay_demo();
	hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);

	return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
