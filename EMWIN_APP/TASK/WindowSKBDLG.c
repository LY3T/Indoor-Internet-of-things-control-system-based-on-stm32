/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.26                          *
*        Compiled Aug  8 2014, 14:49:54                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
#include "EmWinHZFont.h"
#include "WindowSKBDLG.h"
#include "string.h"
//#include "usart.h"
// USER END

#include "DIALOG.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_WINDOW_0        (GUI_ID_USER + 0x00)
#define ID_BUTTON_0        (GUI_ID_USER + 0x01)
#define ID_BUTTON_1        (GUI_ID_USER + 0x02)
#define ID_BUTTON_2        (GUI_ID_USER + 0x03)
#define ID_BUTTON_3        (GUI_ID_USER + 0x04)
#define ID_BUTTON_4        (GUI_ID_USER + 0x05)
#define ID_BUTTON_5        (GUI_ID_USER + 0x06)
#define ID_BUTTON_6        (GUI_ID_USER + 0x07)
#define ID_BUTTON_7        (GUI_ID_USER + 0x08)
#define ID_BUTTON_8        (GUI_ID_USER + 0x09)
#define ID_BUTTON_9        (GUI_ID_USER + 0x0A)
#define ID_BUTTON_10        (GUI_ID_USER + 0x0B)
#define ID_BUTTON_11        (GUI_ID_USER + 0x0C)
#define ID_BUTTON_12        (GUI_ID_USER + 0x0D)
#define ID_BUTTON_13        (GUI_ID_USER + 0x0E)
#define ID_BUTTON_14        (GUI_ID_USER + 0x0F)
#define ID_BUTTON_15        (GUI_ID_USER + 0x10)
#define ID_BUTTON_16        (GUI_ID_USER + 0x11)
#define ID_BUTTON_17        (GUI_ID_USER + 0x12)
#define ID_BUTTON_18        (GUI_ID_USER + 0x13)
#define ID_BUTTON_19        (GUI_ID_USER + 0x14)
#define ID_BUTTON_20        (GUI_ID_USER + 0x15)
#define ID_BUTTON_21        (GUI_ID_USER + 0x16)
#define ID_BUTTON_22        (GUI_ID_USER + 0x17)
#define ID_BUTTON_23        (GUI_ID_USER + 0x18)
#define ID_BUTTON_24        (GUI_ID_USER + 0x19)
#define ID_BUTTON_25        (GUI_ID_USER + 0x1A)
#define ID_BUTTON_26        (GUI_ID_USER + 0x1B)
#define ID_BUTTON_27        (GUI_ID_USER + 0x1C)
#define ID_BUTTON_28        (GUI_ID_USER + 0x1D)
#define ID_BUTTON_29        (GUI_ID_USER + 0x1E)
#define ID_BUTTON_30        (GUI_ID_USER + 0x1F)
#define ID_BUTTON_31        (GUI_ID_USER + 0x20)
#define ID_BUTTON_32        (GUI_ID_USER + 0x21)
#define ID_BUTTON_33        (GUI_ID_USER + 0x22)
#define ID_BUTTON_34        (GUI_ID_USER + 0x23)
#define ID_TEXT_0        (GUI_ID_USER + 0x24)
#define ID_TEXT_1        (GUI_ID_USER + 0x26)
#define ID_TEXT_2        (GUI_ID_USER + 0x27)
#define ID_TEXT_3        (GUI_ID_USER + 0x28)
#define ID_TEXT_4        (GUI_ID_USER + 0x29)
#define ID_TEXT_5        (GUI_ID_USER + 0x2A)
#define ID_TEXT_6        (GUI_ID_USER + 0x2B)
#define ID_TEXT_7        (GUI_ID_USER + 0x2C)
#define ID_TEXT_8        (GUI_ID_USER + 0x2D)


// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)

static const char keyCAP[] = {
'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'ii', 'O', 'P',
'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', '_',
'Z', 'X', 'C', 'V', 'B', 'N', 'M', 0};
static const char keyLOW[] = {
'q', 'w', 'e', 'r', 't', 'y', 'u', 'ii', 'o', 'p',
'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', '_',
'z', 'x', 'c', 'v', 'b', 'n', 'm', 0};
static const char key123[] = {
'1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
'!', '@', '%', '*', '(', ')', '_', '-', '+', '=',
'/', ':', ';', '"', ',', '.', '?', 0};


extern const char *PYSearch(char *strInput_py_str);
WM_HWIN win_skb;

// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "WindowSKB", ID_WINDOW_0, 0, 200, 200, 100, WM_CF_STAYONTOP, 0x0, 0 },
  { BUTTON_CreateIndirect, "q", ID_BUTTON_0, 0, 20, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "w", ID_BUTTON_1, 20, 20, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "e", ID_BUTTON_2, 40, 20, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "r", ID_BUTTON_3, 60, 20, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "t", ID_BUTTON_4, 80, 20, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "y", ID_BUTTON_5, 100, 20, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "u", ID_BUTTON_6, 120, 20, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "i", ID_BUTTON_7, 140, 20, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "o", ID_BUTTON_8, 160, 20, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "p", ID_BUTTON_9, 180, 20, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "a", ID_BUTTON_10, 0, 40, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "s", ID_BUTTON_11, 20, 40, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "d", ID_BUTTON_12, 40, 40, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "f", ID_BUTTON_13, 60, 40, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "g", ID_BUTTON_14, 80, 40, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "h", ID_BUTTON_15, 100, 40, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "j", ID_BUTTON_16, 120, 40, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "k", ID_BUTTON_17, 140, 40, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "l", ID_BUTTON_18, 160, 40, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "_", ID_BUTTON_19, 180, 40, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "z", ID_BUTTON_20, 0, 60, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "x", ID_BUTTON_21, 20, 60, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "c", ID_BUTTON_22, 40, 60, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "v", ID_BUTTON_23, 60, 60, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "b", ID_BUTTON_24, 80, 60, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "n", ID_BUTTON_25, 100, 60, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "m", ID_BUTTON_26, 120, 60, 20, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "<-", ID_BUTTON_27, 140, 60, 30, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "->", ID_BUTTON_28, 170, 60, 30, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Cap", ID_BUTTON_29, 0, 80, 30, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Esc", ID_BUTTON_30, 30, 80, 30, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "", ID_BUTTON_31, 60, 80, 50, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "En", ID_BUTTON_32, 110, 80, 30, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Ent", ID_BUTTON_33, 140, 80, 30, 20, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "<--", ID_BUTTON_34, 170, 80, 30, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "ping", ID_TEXT_0, 0, 0, 40, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "1", ID_TEXT_1, 40, 0, 20, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "2", ID_TEXT_2, 60, 0, 20, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "3", ID_TEXT_3, 80, 0, 20, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "4", ID_TEXT_4, 100, 0, 20, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "5", ID_TEXT_5, 120, 0, 20, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "6", ID_TEXT_6, 140, 0, 20, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "7", ID_TEXT_7, 160, 0, 20, 20, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "8", ID_TEXT_8, 180, 0, 20, 20, 0, 0x64, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)

static unsigned char capsKEY = 0, inputTYPE = 0;
void LOC_button_0to18_20to26_action(WM_MESSAGE * pMsg)
{
  WM_MESSAGE Message;
  char charBUFF[128], tempBUFF[128];
  if(inputTYPE == 0) goto gotoASCII;
  else if(inputTYPE == 1) goto gotoSYMBOL;
  else goto gotoPING;

  gotoASCII:
  BUTTON_GetText(pMsg->hWinSrc, &charBUFF[0], sizeof(charBUFF));
  GUI_StoreKeyMsg(charBUFF[0], 1);//store key to EMWIN
  GUI_StoreKeyMsg(charBUFF[0], 0);
  return;

  gotoSYMBOL:
  BUTTON_GetText(pMsg->hWinSrc, &charBUFF[0], sizeof(charBUFF));
  GUI_StoreKeyMsg(charBUFF[0], 1);
  GUI_StoreKeyMsg(charBUFF[0], 0);
  return;

  gotoPING:
  if(capsKEY)//if Caps is on
  {
    BUTTON_GetText(pMsg->hWinSrc, &charBUFF[0], sizeof(charBUFF));
    GUI_StoreKeyMsg(charBUFF[0], 1);//store key to EMWIN and exit
    GUI_StoreKeyMsg(charBUFF[0], 0);
    return;
  }
  TEXT_GetText(WM_GetDialogItem(pMsg->hWin, ID_TEXT_0), &charBUFF[0], sizeof(charBUFF));
  BUTTON_GetText(pMsg->hWinSrc, &tempBUFF[0], sizeof(tempBUFF));
  strcat(charBUFF, tempBUFF);//connect string
  TEXT_SetText(WM_GetDialogItem(pMsg->hWin, ID_TEXT_0), &charBUFF[0]);

  //send one message to ID_TEXT_0,update ID_TEXT_1~ID_TEXT_9 content
  Message.hWinSrc = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
  Message.MsgId = WM_NOTIFY_PARENT;
  Message.Data.v = WM_NOTIFICATION_USER+0;
  WM_SendMessage(pMsg->hWin, &Message);
}




// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
  int ii,temp;
  char charBUFF[128],tempBUFF[128];
  WM_MESSAGE Message;
  static int *pbuffPY[64];
  static char **pstrPY=(char **)&pbuffPY[0];
  char *pstrTEMP;
	
  int EDIT_SizeX,EDIT_SizeY,EDIT_OrgX,EDIT_OrgY;
	
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'WindowSKB'
    //
    hItem = pMsg->hWin;
    WINDOW_SetBkColor(hItem, 0x00FFFFFF);
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
    BUTTON_SetText(hItem, "q");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);
    BUTTON_SetText(hItem, "w");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_2);
    BUTTON_SetText(hItem, "e");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_3);
    BUTTON_SetText(hItem, "r");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_4);
    BUTTON_SetText(hItem, "t");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_5);
    BUTTON_SetText(hItem, "y");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_6);
    BUTTON_SetText(hItem, "u");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_7);
    BUTTON_SetText(hItem, "i");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_8);
    BUTTON_SetText(hItem, "o");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_9);
    BUTTON_SetText(hItem, "p");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_10);
    BUTTON_SetText(hItem, "a");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_11);
    BUTTON_SetText(hItem, "s");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_12);
    BUTTON_SetText(hItem, "d");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_13);
    BUTTON_SetText(hItem, "f");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_14);
    BUTTON_SetText(hItem, "g");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_15);
    BUTTON_SetText(hItem, "h");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_16);
    BUTTON_SetText(hItem, "j");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_17);
    BUTTON_SetText(hItem, "k");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_18);
    BUTTON_SetText(hItem, "l");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_19);
    BUTTON_SetText(hItem, "_");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_20);
    BUTTON_SetText(hItem, "z");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_21);
    BUTTON_SetText(hItem, "x");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_22);
    BUTTON_SetText(hItem, "c");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_23);
    BUTTON_SetText(hItem, "v");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_24);
    BUTTON_SetText(hItem, "b");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_25);
    BUTTON_SetText(hItem, "n");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_26);
    BUTTON_SetText(hItem, "m");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_27);
    BUTTON_SetText(hItem, "<-");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_28);
    BUTTON_SetText(hItem, "->");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_29);
    BUTTON_SetText(hItem, "Cap");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_30);
    BUTTON_SetText(hItem, "Esc");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_31);
    BUTTON_SetText(hItem, "");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_32);
    BUTTON_SetText(hItem, "En");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_33);
    BUTTON_SetText(hItem, "Ent");
    //
    // Initialization of 'Button'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_34);
    BUTTON_SetText(hItem, "<--");
    //
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "");    
	//
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_1);
	TEXT_SetFont(hItem,&GUI_FontHZ16);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "");
	//
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_2);
	TEXT_SetFont(hItem,&GUI_FontHZ16);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "");
    //
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_3);
	TEXT_SetFont(hItem,&GUI_FontHZ16);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "");
    //
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_4);
	TEXT_SetFont(hItem,&GUI_FontHZ16);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "");
	//
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_5);
	TEXT_SetFont(hItem,&GUI_FontHZ16);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "");
    //
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_6);
	TEXT_SetFont(hItem,&GUI_FontHZ16);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "");
    //
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_7);
	TEXT_SetFont(hItem,&GUI_FontHZ16);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "");
    //
    // Initialization of 'Text'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_8);
	TEXT_SetFont(hItem,&GUI_FontHZ16);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetText(hItem, "");
	// USER START (Optionally insert additional code for further widget initialization)
	
	//disable focus
    for(ii=ID_BUTTON_0; ii<=ID_BUTTON_34; ii++)
		BUTTON_SetFocussable(WM_GetDialogItem(pMsg->hWin, ii), 0); 
	// USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_0: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
		LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_1: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
		LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_2: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_3: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_4: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_5: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_6: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_7: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_8: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_9: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_10: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_11: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_12: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_13: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_14: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_15: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_16: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_17: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_18: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_19: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        BUTTON_GetText(pMsg->hWinSrc, &charBUFF[0], sizeof(charBUFF));
        GUI_StoreKeyMsg(charBUFF[0], 1);
        GUI_StoreKeyMsg(charBUFF[0], 0);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_20: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_21: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
		LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_22: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_23: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
		LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_24: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_25: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_26: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        LOC_button_0to18_20to26_action(pMsg);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_27: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        Message.hWinSrc = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
        Message.MsgId = WM_NOTIFY_PARENT;
        Message.Data.v = WM_NOTIFICATION_USER+1;
        WM_SendMessage(pMsg->hWin, &Message);        
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_28: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        Message.hWinSrc = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
        Message.MsgId = WM_NOTIFY_PARENT;
        Message.Data.v = WM_NOTIFICATION_USER+2;
        WM_SendMessage(pMsg->hWin, &Message);        
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_29: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        //数字键盘无大小写
		if(inputTYPE==1) break;

        capsKEY = !capsKEY;
        if(capsKEY) 
			BUTTON_SetTextColor(pMsg->hWinSrc, BUTTON_CI_UNPRESSED, GUI_RED);
        else 
			BUTTON_SetTextColor(pMsg->hWinSrc, BUTTON_CI_UNPRESSED, GUI_BLACK);

        for(Id=ID_BUTTON_0; Id<=ID_BUTTON_26; Id++)  //change to English keyboard
        {
          charBUFF[0] = capsKEY ? keyCAP[Id-ID_BUTTON_0] : keyLOW[Id-ID_BUTTON_0]; charBUFF[1] = 0;
          BUTTON_SetText(WM_GetDialogItem(pMsg->hWin, Id), &charBUFF[0]);
          BUTTON_SetTextColor(WM_GetDialogItem(pMsg->hWin, Id), BUTTON_CI_UNPRESSED, (!capsKEY&&(inputTYPE==2)) ? GUI_BLUE : GUI_BLACK);
        }
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_30: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        WM_HideWindow(pMsg->hWin);

        //renew all keys include caps
        inputTYPE = (inputTYPE <= 0) ? 2 : (inputTYPE-1);
        Message.hWinSrc = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_32);
        Message.MsgId = WM_NOTIFY_PARENT;
        Message.Data.v = WM_NOTIFICATION_RELEASED;
        WM_SendMessage(pMsg->hWin, &Message);		
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_31: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        GUI_StoreKeyMsg(GUI_KEY_SPACE, 1);
        GUI_StoreKeyMsg(GUI_KEY_SPACE, 0);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_32: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        inputTYPE = (inputTYPE >= 2) ? 0 : (inputTYPE+1);

        capsKEY = 0;
        BUTTON_SetTextColor(WM_GetDialogItem(pMsg->hWin, ID_BUTTON_29), BUTTON_CI_UNPRESSED, GUI_BLACK);
        if(inputTYPE==2) for(ii=ID_BUTTON_0; ii<=ID_BUTTON_26; ii++) BUTTON_SetTextColor(WM_GetDialogItem(pMsg->hWin, ii), BUTTON_CI_UNPRESSED, GUI_BLUE);
        else for(ii=ID_BUTTON_0; ii<=ID_BUTTON_26; ii++) BUTTON_SetTextColor(WM_GetDialogItem(pMsg->hWin, ii), BUTTON_CI_UNPRESSED, GUI_BLACK);

        if(inputTYPE == 0) goto gotoEN;
        else if(inputTYPE == 1) goto goto123;
        else goto gotoCH;

        gotoEN:
        BUTTON_SetText(pMsg->hWinSrc, "EN");
        for(Id=ID_BUTTON_0; Id<=ID_BUTTON_26; Id++)//change to English keyboard
        {
          charBUFF[0] = keyLOW[Id-ID_BUTTON_0]; charBUFF[1] = 0;
          BUTTON_SetText(WM_GetDialogItem(pMsg->hWin, Id), &charBUFF[0]);
        }
        goto gotoEXIT;

        goto123:
        BUTTON_SetText(pMsg->hWinSrc, "123");
        for(Id=ID_BUTTON_0; Id<=ID_BUTTON_26; Id++)//change to symbol keyboard
        {
          charBUFF[0] = key123[Id-ID_BUTTON_0]; charBUFF[1] = 0;
          BUTTON_SetText(WM_GetDialogItem(pMsg->hWin, Id), &charBUFF[0]);
        }
        goto gotoEXIT;

        gotoCH:
        BUTTON_SetText(pMsg->hWinSrc, "CH");    //change to Chinese keyboard
        for(Id=ID_BUTTON_0; Id<=ID_BUTTON_26; Id++)
        {
          charBUFF[0] = keyLOW[Id-ID_BUTTON_0]; charBUFF[1] = 0;
          BUTTON_SetText(WM_GetDialogItem(pMsg->hWin, Id), &charBUFF[0]);
        }
        goto gotoEXIT;

        gotoEXIT:
        TEXT_SetText(WM_GetDialogItem(pMsg->hWin, ID_TEXT_0), "");

        //send one message to ID_TEXT_0,update ID_TEXT_1~ID_TEXT_9 content
        Message.hWinSrc = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
        Message.MsgId = WM_NOTIFY_PARENT;
        Message.Data.v = WM_NOTIFICATION_USER+0;
        WM_SendMessage(pMsg->hWin, &Message);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_33: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        GUI_StoreKeyMsg(GUI_KEY_ENTER, 1);
        GUI_StoreKeyMsg(GUI_KEY_ENTER, 0);
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_34: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        if((inputTYPE==2) && !capsKEY && (ii=TEXT_GetText(WM_GetDialogItem(pMsg->hWin, ID_TEXT_0), &charBUFF[0], sizeof(charBUFF))))
        {
          charBUFF[ii-1] = 0;  //delete the last char
          TEXT_SetText(WM_GetDialogItem(pMsg->hWin, ID_TEXT_0), &charBUFF[0]);

          //send one message to ID_TEXT_0,update ID_TEXT_1~ID_TEXT_9 content
          Message.hWinSrc = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
          Message.MsgId = WM_NOTIFY_PARENT;
          Message.Data.v = WM_NOTIFICATION_USER+0;
          WM_SendMessage(pMsg->hWin, &Message);
        }
        if(((inputTYPE!=2)) || capsKEY || !ii)
        {
          GUI_StoreKeyMsg(GUI_KEY_BACKSPACE, 1);
          GUI_StoreKeyMsg(GUI_KEY_BACKSPACE, 0);
        }
		// USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)

    case ID_TEXT_0:
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
      case WM_NOTIFICATION_RELEASED:
      break;
      case WM_NOTIFICATION_USER+0:
      case WM_NOTIFICATION_USER+1:
      case WM_NOTIFICATION_USER+2:
        if(NCode == WM_NOTIFICATION_USER+0)
        {
          TEXT_GetText(pMsg->hWinSrc, &charBUFF[0], sizeof(charBUFF));//Get ID_TEXT_0 text
          for(ii=0; ii<sizeof(pbuffPY)/4; ii++) pbuffPY[ii] = 0;
          pstrPY = (char **)&pbuffPY[0];
          pstrTEMP = (char *)PYSearch(&charBUFF[0]);
          //每8个汉字储存一个指针到pbuffPY[ii]
          for(ii=0; pstrTEMP&&*pstrTEMP&&(ii<sizeof(pbuffPY)/4-1); ii++)
          {
            pbuffPY[ii] = (int *)pstrTEMP;
            //pstrTEMP move 9 Chinese characters
            for(temp=ID_TEXT_1; temp<=ID_TEXT_8; temp++)
            {
              pstrTEMP = pstrTEMP + GUI_pUC_API->pfGetCharSize(pstrTEMP);//Using 'pfGetCharSize' to calculate bytes of one Chinese character
              if(!pstrTEMP || !*pstrTEMP) break;
            }
          }
        }
        else if(NCode == WM_NOTIFICATION_USER+1)//'<-'
        {
          if(*(pstrPY-1) && (pstrPY != (char **)&pbuffPY[0])) pstrPY--;
        }
        else if(NCode == WM_NOTIFICATION_USER+2)//'->'
        {
          if(*(pstrPY+1) && (pstrPY!=(char **)&pbuffPY[sizeof(pbuffPY)/4-1])) pstrPY++; else pstrPY = (char **)&pbuffPY[0];
        }

        //Display characters to ID_TEXT_1~ID_TEXT_8
        for(pstrTEMP = *pstrPY, ii=ID_TEXT_1; ii<=ID_TEXT_8; ii++)
        {
          memset(&tempBUFF[0], 0, sizeof(tempBUFF));
          if(!pstrTEMP || !*pstrTEMP) {TEXT_SetText(WM_GetDialogItem(pMsg->hWin, ii), ""); continue;}

          memcpy(&tempBUFF[0], pstrTEMP, temp = GUI_pUC_API->pfGetCharSize(pstrTEMP));//temp = bytes of a Chinese character
          TEXT_SetText(WM_GetDialogItem(pMsg->hWin, ii), &tempBUFF[0]);//display the Chinese character
          pstrTEMP = pstrTEMP + temp;
        }
      break;
      }
      break;

    case ID_TEXT_1:
    case ID_TEXT_2:
    case ID_TEXT_3:
    case ID_TEXT_4:
    case ID_TEXT_5:
    case ID_TEXT_6:
    case ID_TEXT_7:
    case ID_TEXT_8:
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        break;
      case WM_NOTIFICATION_RELEASED:
        if(inputTYPE!=2) break;
        if(TEXT_GetText(WM_GetDialogItem(pMsg->hWin, Id), &tempBUFF[0], sizeof(tempBUFF)) == 0) break;
        EDIT_GetText(hItem=WM_GetFocussedWindow(), &charBUFF[0], sizeof(charBUFF));
        strcat(charBUFF, tempBUFF);
        EDIT_SetText(hItem, &charBUFF[0]);

        //send one message to ID_TEXT_0,update ID_TEXT_1~ID_TEXT_8 content
        TEXT_SetText(WM_GetDialogItem(pMsg->hWin, ID_TEXT_0), "");
        Message.hWinSrc = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
        Message.MsgId = WM_NOTIFY_PARENT;
        Message.Data.v = WM_NOTIFICATION_USER+0;
        WM_SendMessage(pMsg->hWin, &Message);
        break;
      }
      break;	  
	  
	  
	// USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
	case WM_USER+1://show skb
		EDIT_SizeY = WM_GetWindowSizeY(pMsg->hWinSrc);
		EDIT_OrgY  = WM_GetWindowOrgY(pMsg->hWinSrc);
		//printf("sizeY:%d orgY:%d\r\n",EDIT_SizeY,EDIT_OrgY);
		WM_MoveTo(pMsg->hWin,20,(EDIT_SizeY+EDIT_OrgY+100)<290?320-30-100-10:EDIT_OrgY-100);
		WM_ShowWindow(pMsg->hWin);
		break;
	

  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindowSKB
*/

WM_HWIN CreateWindowSKB(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  return hWin;
}

// USER START (Optionally insert additional public code)

void show_skb(WM_MESSAGE * pMsg)
{
	WM_MESSAGE Message;
	Message.MsgId = WM_USER + 1;
	Message.hWinSrc = pMsg->hWinSrc;
	WM_SendMessage(win_skb,&Message);
}



// USER END

/*************************** End of file ****************************/
